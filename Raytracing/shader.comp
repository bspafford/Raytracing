#version 430 core
#extension GL_ARB_bindless_texture : enable

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
	
// images 
layout(rgba32f, binding = 0) uniform image2D imgOutput;

struct Vertex {
	vec3 position; float pad1;
    vec3 normal;   float pad2;
    vec3 color;    float pad3;
    vec2 texUV;    vec2 pad4;
	vec4 tangent;
};

struct MaterialData {
	sampler2D baseColorTexture;
	sampler2D normalTexture;
	sampler2D metallicRoughnessTexture;
	int hasBaseTexture;
	int hasNormalTexture;
	int hasMetallicRoughnessTexture;
	float metallicFactor;
	float roughnessFactor;
};

// variables
layout(std430, binding = 0) buffer VertexBuffer  { Vertex vertices[]; };
layout(std430, binding = 1) buffer Indices { uint indices[]; };
layout(std430, binding = 2) buffer MeshProj { mat4 meshProj[]; };
layout(std430, binding = 3) buffer MeshStartLoc { uint meshStartLoc[]; };
layout(std430, binding = 4) buffer MaterialList { MaterialData materialList[]; };

uniform mat4 projection;
uniform mat4 invProj;
uniform vec3 camPos;
uniform vec3 camOrientation;
uniform mat4 view;
uniform mat4 invView;
uniform float aspect;
uniform float fov;
uniform vec3 lightDir;

bool RayIntersectsTriangle(vec3 orig, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 hitLoc) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 p = cross(dir, e2);
    float det = dot(e1, p);
    if (abs(det) < 1e-8) return false;

    float invDet = 1.0 / det;
    vec3 s = orig - v0;
    float u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(s, e1);
    float v = dot(dir, q) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;

    float t = dot(e2, q) * invDet;
    if (t < 1e-8) return false;

    hitLoc = orig + dir * t;
    return true;
}

vec3 barycentric(vec3 p, vec3 a, vec3 b, vec3 c) {
    vec3 v0 = b - a;
    vec3 v1 = c - a;
    vec3 v2 = p - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;
    return vec3(u, v, w);
}

float average(vec3 v) {
	return (v.x + v.y + v.z) / 3.f;
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(imgOutput);

	if (pixel.x >= size.x || pixel.y >= size.y) return;

	// make ray
	vec2 uv = (vec2(pixel) / vec2(size)) * 2.f - 1.f;
	uv.x *= aspect;
	vec3 camForward = normalize(camOrientation);
	vec3 camRight = normalize(cross(camForward, vec3(0.f, 1.f, 0.f)));
	vec3 camUp = cross(camRight, camForward);
	float px = uv.x * tan(radians(fov) / 2.f);
	float py = uv.y * tan(radians(fov) / 2.f);
	vec3 rayDir = normalize(camForward + px * camRight + py * camUp);

	// background color
	vec3 throughput = vec3(1.f);
	vec4 color = vec4(1);
	vec3 startPos = camPos;
	vec3 startDir = rayDir;
	vec2 hitUV;
	uint hitMeshIndex;
	int maxBounces = 5;
	for (int bounce = 0; bounce < maxBounces; ++bounce) {
		uint meshIndex = 0;
		vec3 hitLoc;
		vec3 hitNormal;
		float closestDist = 3.40282347e+38;
		vec3 hitP1;
		vec3 hitP2;
		vec3 hitP3;
		uint closestIndices[3];
		bool hit = false;
		for (int i = 0; i < indices.length(); i += 3) {
			if (meshIndex + 1 < meshStartLoc.length() && i == meshStartLoc[meshIndex + 1])
				meshIndex++;

			uint i1 = indices[i];
			uint i2 = indices[i+1];
			uint i3 = indices[i+2];

			vec3 p1 = vec3(meshProj[meshIndex] * vec4(vertices[i1].position, 1.f));
			vec3 p2 = vec3(meshProj[meshIndex] * vec4(vertices[i2].position, 1.f));
			vec3 p3 = vec3(meshProj[meshIndex] * vec4(vertices[i3].position, 1.f));

			vec3 _hitLoc;
			if (RayIntersectsTriangle(startPos, startDir, p1, p2, p3, _hitLoc)) {
				float newDist = distance(startPos, _hitLoc);
				if (newDist < closestDist) {
					hit = true;
					hitLoc = _hitLoc;
					closestDist = newDist;

					hitP1 = p1;
					hitP2 = p2;
					hitP3 = p3;

					closestIndices[0] = i1;
					closestIndices[1] = i2;
					closestIndices[2] = i3;

					hitMeshIndex = meshIndex;
				}
			}
		}

		if (hit) {
			uint i1 = closestIndices[0];
			uint i2 = closestIndices[1];
			uint i3 = closestIndices[2];

			vec3 bary = barycentric(hitLoc, hitP1, hitP2, hitP3);

			vec3 n1 = vec3(meshProj[meshIndex] * vec4(vertices[i1].normal, 0.f));
			vec3 n2 = vec3(meshProj[meshIndex] * vec4(vertices[i2].normal, 0.f));
			vec3 n3 = vec3(meshProj[meshIndex] * vec4(vertices[i3].normal, 0.f));
			hitNormal = normalize(n1 * bary.x + n2 * bary.y + n3 * bary.z);

			vec3 c1 = vertices[i1].color;
			vec3 c2 = vertices[i2].color;
			vec3 c3 = vertices[i3].color;

			vec2 uv1 = vertices[i1].texUV;
			vec2 uv2 = vertices[i2].texUV;
			vec2 uv3 = vertices[i3].texUV;

			hitUV = uv1 * bary.x + uv2 * bary.y + uv3 * bary.z;

			startPos = hitLoc + (hitNormal * 1e-5);
			
			MaterialData material = materialList[hitMeshIndex];
			float metallicFactor;
			float roughnessFactor;
			if (material.hasMetallicRoughnessTexture == 1) {
				metallicFactor = texture(material.metallicRoughnessTexture, hitUV).r;
				roughnessFactor = texture(material.metallicRoughnessTexture, hitUV).g;
			} else {
				metallicFactor = material.metallicFactor;
				roughnessFactor = material.roughnessFactor;
			}

			vec3 tempHit;
			meshIndex = 0;
			float brightness = 1.f;
			for (int i = 0; i < indices.length(); i += 3) {
				if (meshIndex + 1 < meshStartLoc.length() && i == meshStartLoc[meshIndex + 1])
					meshIndex++;
				uint i1 = indices[i];
				uint i2 = indices[i+1];
				uint i3 = indices[i+2];
				vec3 p1 = vec3(meshProj[meshIndex] * vec4(vertices[i1].position, 1.f));
				vec3 p2 = vec3(meshProj[meshIndex] * vec4(vertices[i2].position, 1.f));
				vec3 p3 = vec3(meshProj[meshIndex] * vec4(vertices[i3].position, 1.f));
				if (RayIntersectsTriangle(startPos, lightDir, p1, p2, p3, tempHit)) {
					// how much of the light / sun can i see, for soft shadows
					// then darkent the cololr by that much?
					brightness = .5f;
					break;
				}
			}

			vec3 baseColor = texture(material.baseColorTexture, hitUV).rgb;
			vec3 diffuseColor = baseColor * (1.f - metallicFactor);
			color.rgb = mix(color.rgb, diffuseColor, throughput) * brightness; // or some factor based on bounce
			throughput *= average(baseColor);

			if (metallicFactor > 0) { // just reflect perfectly off normal if metallic isn't 0
				if (dot(startDir, hitNormal) > 0.f)
					hitNormal = -hitNormal; // ensure normal opposes the ray

				if (material.hasNormalTexture == 1) {
					vec3 tangent = normalize(vertices[i1].tangent.xyz * bary.x + vertices[i2].tangent.xyz * bary.y + vertices[i3].tangent.xyz * bary.z);
					float handedness = vertices[i1].tangent.w * bary.x + vertices[i2].tangent.w * bary.y + vertices[i3].tangent.w * bary.z;

					vec3 normalTex = normalize(texture(material.normalTexture, hitUV).rgb * 2.0 - 1.0); // [0, 1] -> [-1, 1

					float normalStrength = 1.f; // 1.0 = default, 0.5 = half bumps, 2.0 = exaggerated
					normalTex.xy *= normalStrength;

					vec3 bitangent = cross(hitNormal, tangent) * handedness;
					mat3 TBN = mat3(tangent, bitangent, hitNormal);
					vec3 worldNormal = normalize(TBN * normalTex);
					startDir = normalize(reflect(startDir, worldNormal));
				} else
					startDir = normalize(reflect(startDir, hitNormal));

			} else if (metallicFactor == 0) { // light doesn't bounce, so stop looking
				break;
			}
		} else { // didn't hit anything
			break;
		}
	}

    imageStore(imgOutput, pixel, color);
}