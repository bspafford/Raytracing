#version 430 core
#extension GL_ARB_bindless_texture : enable
#extension GL_ARB_gpu_shader_int64 : enable

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
	
// images 
layout(rgba32f, binding = 0) uniform image2D imgOutput;

struct Vertex {
	vec3 position;
    vec3 normal;
    vec3 color;
    vec2 texUV;
	vec4 tangent;
};

struct MaterialData {
	vec4 baseColorFactor;

	int64_t baseColorTexture;
	int hasBaseTexture;
	float transmissionFactor;

	int64_t normalTexture;
	int hasNormalTexture;
	float metallicFactor;

	int64_t metallicRoughnessTexture;
	int hasMetallicRoughnessTexture;
	float roughnessFactor;

	float ior;
	float pad1[3];
};

struct GPUBoundingBox {
	vec3 minLoc;
	vec3 maxLoc;
	uint isLeaf;
	ivec4 children;
};

struct Triangle {
	uvec3 indices;
	vec3 p1;
	vec3 p2;
	vec3 p3;
	vec3 centroidLoc;
	uvec4 meshIndex;
};

struct Ray {
	vec3 loc;
	vec3 dir;
	vec3 strength;
};

// variables
layout(std430, binding = 0) buffer VertexBuffer { Vertex vertices[]; };
layout(std430, binding = 1) buffer MeshProj { mat4 meshProj[]; };
layout(std430, binding = 2) buffer MaterialList { MaterialData materialList[]; };
layout(std430, binding = 3) buffer GPUBoundingBoxList { GPUBoundingBox boundingBoxList[]; };
layout(std430, binding = 4) buffer Triangles { Triangle triangleList[]; };

uniform mat4 projection;
uniform mat4 invProj;
uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;
uniform mat4 view;
uniform mat4 invView;
uniform float aspect;
uniform float fov;
uniform vec3 lightDir;

bool RayIntersectsTriangle(vec3 orig, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 hitLoc) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 p = cross(dir, e2);
    float det = dot(e1, p);
    if (abs(det) < 1e-8) return false;

    float invDet = 1.0 / det;
    vec3 s = orig - v0;
    float u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(s, e1);
    float v = dot(dir, q) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;

    float t = dot(e2, q) * invDet;
    if (t < 1e-8) return false;

    hitLoc = orig + dir * t;
    return true;
}

struct Hit {
	vec3 hitLoc;
	Triangle triangle;
};

vec3 barycentric(Hit hit) {
	vec3 p = hit.hitLoc;
	vec3 a = hit.triangle.p1;
	vec3 b = hit.triangle.p2;
	vec3 c = hit.triangle.p3;
	
    vec3 v0 = b - a;
    vec3 v1 = c - a;
    vec3 v2 = p - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;
    return vec3(u, v, w);
}

float average(vec3 v) {
	return (v.x + v.y + v.z) / 3.f;
}

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

bool intersectAABB(const vec3 rayOrigin, const vec3 rayDir, const vec3 aabbMin, const vec3 aabbMax) {
    vec3 invDir = 1.0f / rayDir;

    vec3 t0 = (aabbMin - rayOrigin) * invDir;
    vec3 t1 = (aabbMax - rayOrigin) * invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tEnter = max(max(tmin.x, tmin.y), tmin.z);
    float tExit  = min(min(tmax.x, tmax.y), tmax.z);

    return tExit >= tEnter && tExit >= 0.0f;
}

float fresnelReflectance(vec3 I, vec3 N, float ior1, float ior2) {
    float cosi = clamp(dot(-I, N), -1.0, 1.0);
    float r0 = (ior1 - ior2) / (ior1 + ior2);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow(1.0 - cosi, 5.0);
}

bool lineCast(vec3 startPos, vec3 startDir, out Hit hit, bool breakOnHit = false) {
	bool didHit = false;
	float closestDist = 3.40282347e+38;
	uint stack[64];
	uint stackPtr = 0;
	stack[stackPtr++] = 0;

	while (stackPtr > 0) {
		uint nodeIndex = stack[--stackPtr];
		GPUBoundingBox node = boundingBoxList[nodeIndex];

		// test left and right for AABB intersection
		if (intersectAABB(startPos, startDir, node.minLoc, node.maxLoc)) {
			// test triangle in leaf
			if (node.isLeaf == 1) { // at leaf node
				for (int i = 0; i < 4; i++) {
					if (node.children[i] != -1) {
						Triangle triangle = triangleList[node.children[i]];

						vec3 p1 = vec3(meshProj[triangle.meshIndex.x] * vec4(vertices[triangle.indices.x].position, 1.f));
						vec3 p2 = vec3(meshProj[triangle.meshIndex.x] * vec4(vertices[triangle.indices.y].position, 1.f));
						vec3 p3 = vec3(meshProj[triangle.meshIndex.x] * vec4(vertices[triangle.indices.z].position, 1.f));

						vec3 _hitLoc;
						if (RayIntersectsTriangle(startPos, startDir, p1, p2, p3, _hitLoc)) {
							float newDist = dot(startPos - _hitLoc, startPos - _hitLoc);
							if (newDist < closestDist) {
								didHit = true;
								hit.hitLoc = _hitLoc;
								closestDist = newDist;

								hit.triangle = triangle;

								if (breakOnHit)
									return true;
							}
						}
					}
				}
			} else { // hit bounding box, not at leaf node
				if (node.children.x != -1)
					stack[stackPtr++] = node.children.x; // left child;
				if (node.children.y != -1)
					stack[stackPtr++] = node.children.y; // right child;
			}
		}
	}

	return didHit;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(imgOutput);

	if (pixel.x >= size.x || pixel.y >= size.y) return;

	// make ray
	vec2 uv = (vec2(pixel) / vec2(size)) * 2.f - 1.f;
	uv.x *= aspect;
	float px = uv.x * tan(radians(fov) / 2.f);
	float py = uv.y * tan(radians(fov) / 2.f);
	vec3 rayDir = normalize(camForward + px * camRight + py * camUp);

	// background color
	vec3 throughput = vec3(1.f);
	vec4 color = vec4(0.f);
	int maxBounces = 5;
	const uint activeRaysNum = 8;
	Ray activeRays[activeRaysNum];
	int rayTailPtr = 0; // how many items in list
	activeRays[rayTailPtr++] = Ray(camPos, rayDir, vec3(1)); // add item to list
	for (int bounce = 0; bounce < maxBounces; ++bounce) {
		for (int i = 0; i < min(rayTailPtr, activeRaysNum); i++) {
			Hit hit;
			bool didHit = lineCast(activeRays[i].loc, activeRays[i].dir, hit);
			if (!didHit)
				break;

			uint i1 = hit.triangle.indices.x;
			uint i2 = hit.triangle.indices.y;
			uint i3 = hit.triangle.indices.z;

			vec3 bary = barycentric(hit);

			vec3 n1 = vec3(meshProj[hit.triangle.meshIndex.x] * vec4(vertices[i1].normal, 0.f));
			vec3 n2 = vec3(meshProj[hit.triangle.meshIndex.x] * vec4(vertices[i2].normal, 0.f));
			vec3 n3 = vec3(meshProj[hit.triangle.meshIndex.x] * vec4(vertices[i3].normal, 0.f));
			vec3 hitNormal = normalize(n1 * bary.x + n2 * bary.y + n3 * bary.z);

			vec3 c1 = vertices[i1].color;
			vec3 c2 = vertices[i2].color;
			vec3 c3 = vertices[i3].color;

			vec2 uv1 = vertices[i1].texUV;
			vec2 uv2 = vertices[i2].texUV;
			vec2 uv3 = vertices[i3].texUV;

			vec2 hitUV = uv1 * bary.x + uv2 * bary.y + uv3 * bary.z;

			activeRays[i].loc = hit.hitLoc + (hitNormal * 1e-5);
			
			MaterialData material = materialList[hit.triangle.meshIndex.x];

			if (material.transmissionFactor > 0) { // transmissive
				float iorAir = 1;
				bool entering = dot(activeRays[i].dir, hitNormal) < 0;
				vec3 normal = entering ? hitNormal : -hitNormal;
				float eta = entering ? iorAir / material.ior : material.ior / iorAir;
				activeRays[i].loc = hit.hitLoc - normal * 1e-5f;
				// add reflection ray
				if (rayTailPtr < activeRaysNum - 1 && entering) { // if there aren't that many rays 
					Ray reflectRay = Ray(hit.hitLoc + hitNormal * 1e-5f, vec3(0), vec3(1));
					vec3 normal;
					if (material.hasNormalTexture == 1) {
						vec3 tangent = (vertices[i1].tangent.xyz * bary.x + vertices[i2].tangent.xyz * bary.y + vertices[i3].tangent.xyz * bary.z);
						float handedness = vertices[i1].tangent.w * bary.x + vertices[i2].tangent.w * bary.y + vertices[i3].tangent.w * bary.z;

						vec3 normalTex = texture(sampler2D(material.normalTexture), hitUV).rgb * 2.0 - 1.0; // [0, 1] -> [-1, 1]

						float normalStrength = 1.f;
						normalTex.xy *= normalStrength;

						vec3 bitangent = cross(hitNormal, tangent) * handedness;
						mat3 TBN = mat3(tangent, bitangent, hitNormal);
						normal = (TBN * normalTex);
						reflectRay.dir = reflect(activeRays[i].dir, normal);
					} else {
						normal = hitNormal;
						reflectRay.dir = reflect(activeRays[i].dir, hitNormal);
					}
				
					float reflectionStrength = fresnelReflectance(activeRays[i].dir, normal, iorAir, material.ior);
					reflectRay.strength *= reflectionStrength;
					activeRays[i].strength = vec3(1 - reflectionStrength);

					activeRays[rayTailPtr++] = reflectRay;
				}
				activeRays[i].dir = refract(activeRays[i].dir, normal, eta);
			} else {
				float metallicFactor;
				float roughnessFactor;
				if (material.hasMetallicRoughnessTexture == 1) {
					metallicFactor = texture(sampler2D(material.metallicRoughnessTexture), hitUV).r;
					roughnessFactor = texture(sampler2D(material.metallicRoughnessTexture), hitUV).g;
				} else {
					metallicFactor = material.metallicFactor.x;
					roughnessFactor = material.roughnessFactor.x;
				}

				Hit shadowHit;
				float brightness = 1.f;
				if (lineCast(activeRays[i].loc, lightDir, shadowHit, true))
					brightness = .5f;

				vec3 baseColor = material.baseColorFactor.xyz;
				if (material.hasBaseTexture == 1)
					baseColor = texture(sampler2D(material.baseColorTexture), hitUV).rgb;

				vec3 viewDir = normalize(camPos - hit.hitLoc);
				vec3 halfDir = normalize(viewDir + lightDir);

				vec3 F0 = mix(vec3(0.04), baseColor, metallicFactor);
				float fresnel = pow(1.0 - dot(viewDir, halfDir), 5.0);
				vec3 F = F0 + (1.0 - F0) * fresnel;

				vec3 diffuse = baseColor * (1.f - metallicFactor);
				vec3 specular = F;

				color.rgb = (diffuse) * activeRays[i].strength;
				activeRays[i].strength *= F;

				if (dot(activeRays[i].dir, hitNormal) > 0.f)
					hitNormal = -hitNormal; // ensure normal opposes the ray

				// metallic
				if (material.hasNormalTexture == 1) {
					vec3 tangent = (vertices[i1].tangent.xyz * bary.x + vertices[i2].tangent.xyz * bary.y + vertices[i3].tangent.xyz * bary.z);
					float handedness = vertices[i1].tangent.w * bary.x + vertices[i2].tangent.w * bary.y + vertices[i3].tangent.w * bary.z;

					vec3 normalTex = texture(sampler2D(material.normalTexture), hitUV).rgb * 2.0 - 1.0; // [0, 1] -> [-1, 1]

					float normalStrength = 1.f;
					normalTex.xy *= normalStrength;

					vec3 bitangent = cross(hitNormal, tangent) * handedness;
					mat3 TBN = mat3(tangent, bitangent, hitNormal);
					vec3 worldNormal = (TBN * normalTex);
					activeRays[i].dir = reflect(activeRays[i].dir, worldNormal);
				} else
					activeRays[i].dir = reflect(activeRays[i].dir, hitNormal);
			}
		}
	}

	imageStore(imgOutput, pixel, color);
}