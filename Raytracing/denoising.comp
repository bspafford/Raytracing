#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D imgInput;
layout(rgba32f, binding = 1) uniform image2D albedoInput;
layout(rgba32f, binding = 2) uniform image2D normalInput;
layout(rgba32f, binding = 3) uniform image2D depthInput;
layout(rgba32f, binding = 4) uniform image2D blurredOutput;

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(imgInput);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec3 currColor  = imageLoad(imgInput, pixel).rgb;
    vec3 currAlbedo = imageLoad(albedoInput, pixel).rgb;

    vec3 currNormal = normalize(imageLoad(normalInput, pixel).xyz * 2.0 - 1.0);
    float currDepth = imageLoad(depthInput, pixel).r;

    const int blurRadius = 2;

    // Tunable parameters
    float spatialSigma = blurRadius * 0.8;
    float sigmaColor  = 0.3;
    float sigmaNormal = 0.2;
    float sigmaDepth  = 1.0;

    float totalWeight = 0.0;
    vec3 sum = vec3(0);

    for (int y = -blurRadius; y <= blurRadius; ++y) {
        for (int x = -blurRadius; x <= blurRadius; ++x) {
            ivec2 coord = clamp(pixel + ivec2(x, y), ivec2(0), size - 1);

            vec3 color  = imageLoad(imgInput,  coord).rgb;
            vec3 albedo = imageLoad(albedoInput, coord).rgb;
            vec3 normal = normalize(imageLoad(normalInput, coord).xyz * 2.0 - 1.0);
            float depth = imageLoad(depthInput, coord).r;

            // Spatial weight
            float r2 = float(x*x + y*y);
            float wSpatial = exp(-r2 / (2.0 * spatialSigma * spatialSigma));

            // Albedo (color) difference
            float colorDiff = length(currAlbedo - albedo);
            float wColor = exp(-(colorDiff*colorDiff) / (2.0 * sigmaColor * sigmaColor));

            // Normal difference
            float normalDiff = 1.0 - dot(currNormal, normal);
            float wNormal = exp(-(normalDiff*normalDiff) / (2.0 * sigmaNormal * sigmaNormal));

            // Depth difference
            float depthDiff = abs(currDepth - depth);
            float wDepth = exp(-(depthDiff*depthDiff) / (2.0 * sigmaDepth * sigmaDepth));

            float w = wSpatial * wColor * wNormal * wDepth;

            sum += color * w;
            totalWeight += w;
        }
    }

    vec3 color  = imageLoad(imgInput, pixel).rgb;
    vec3 finalColor = sum / max(totalWeight, 1e-6);
    imageStore(blurredOutput, pixel, vec4(finalColor, 1.0));
}